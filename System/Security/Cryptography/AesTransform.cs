internal class AesTransform : SymmetricTransform // TypeDefIndex: 2161
{
	// Fields
	private uint[] expandedKey; // 0x58
	private int Nk; // 0x60
	private int Nr; // 0x64
	private static readonly uint[] Rcon; // 0x0
	private static readonly byte[] SBox; // 0x8
	private static readonly byte[] iSBox; // 0x10
	private static readonly uint[] T0; // 0x18
	private static readonly uint[] T1; // 0x20
	private static readonly uint[] T2; // 0x28
	private static readonly uint[] T3; // 0x30
	private static readonly uint[] iT0; // 0x38
	private static readonly uint[] iT1; // 0x40
	private static readonly uint[] iT2; // 0x48
	private static readonly uint[] iT3; // 0x50

	// Methods

	// RVA: 0x1B58C60 Offset: 0x1B58D61 VA: 0x1B58C60
	public void .ctor(Aes algo, bool encryption, byte[] key, byte[] iv) { }

	// RVA: 0x1B5A040 Offset: 0x1B5A141 VA: 0x1B5A040 Slot: 15
	protected override void ECB(byte[] input, byte[] output) { }

	// RVA: 0x1B59F60 Offset: 0x1B5A061 VA: 0x1B59F60
	private uint SubByte(uint a) { }

	// RVA: 0x1B5A060 Offset: 0x1B5A161 VA: 0x1B5A060
	private void Encrypt128(byte[] indata, byte[] outdata, uint[] ekey) { }

	// RVA: 0x1B5BEB0 Offset: 0x1B5BFB1 VA: 0x1B5BEB0
	private void Decrypt128(byte[] indata, byte[] outdata, uint[] ekey) { }

	// RVA: 0x1B5DCF0 Offset: 0x1B5DDF1 VA: 0x1B5DCF0
	private static void .cctor() { }
}

internal class AesTransform : SymmetricTransform // TypeDefIndex: 2161
{
	// Fields
	private uint[] expandedKey; // 0x58
	private int Nk; // 0x60
	private int Nr; // 0x64
	private static readonly uint[] Rcon; // 0x0
	private static readonly byte[] SBox; // 0x8
	private static readonly byte[] iSBox; // 0x10
	private static readonly uint[] T0; // 0x18
	private static readonly uint[] T1; // 0x20
	private static readonly uint[] T2; // 0x28
	private static readonly uint[] T3; // 0x30
	private static readonly uint[] iT0; // 0x38
	private static readonly uint[] iT1; // 0x40
	private static readonly uint[] iT2; // 0x48
	private static readonly uint[] iT3; // 0x50

	// Methods

	// RVA: 0x1B58C60 Offset: 0x1B58D61 VA: 0x1B58C60
	public void .ctor(Aes algo, bool encryption, byte[] key, byte[] iv) { }

	// RVA: 0x1B5A040 Offset: 0x1B5A141 VA: 0x1B5A040 Slot: 15
	protected override void ECB(byte[] input, byte[] output) { }

	// RVA: 0x1B59F60 Offset: 0x1B5A061 VA: 0x1B59F60
	private uint SubByte(uint a) { }

	// RVA: 0x1B5A060 Offset: 0x1B5A161 VA: 0x1B5A060
	private void Encrypt128(byte[] indata, byte[] outdata, uint[] ekey) { }

	// RVA: 0x1B5BEB0 Offset: 0x1B5BFB1 VA: 0x1B5BEB0
	private void Decrypt128(byte[] indata, byte[] outdata, uint[] ekey) { }

	// RVA: 0x1B5DCF0 Offset: 0x1B5DDF1 VA: 0x1B5DCF0
	private static void .cctor() { }
}

internal class AesTransform : SymmetricTransform // TypeDefIndex: 2161
{
	// Fields
	private uint[] expandedKey; // 0x58
	private int Nk; // 0x60
	private int Nr; // 0x64
	private static readonly uint[] Rcon; // 0x0
	private static readonly byte[] SBox; // 0x8
	private static readonly byte[] iSBox; // 0x10
	private static readonly uint[] T0; // 0x18
	private static readonly uint[] T1; // 0x20
	private static readonly uint[] T2; // 0x28
	private static readonly uint[] T3; // 0x30
	private static readonly uint[] iT0; // 0x38
	private static readonly uint[] iT1; // 0x40
	private static readonly uint[] iT2; // 0x48
	private static readonly uint[] iT3; // 0x50

	// Methods

	// RVA: 0x1B58C60 Offset: 0x1B58D61 VA: 0x1B58C60
	public void .ctor(Aes algo, bool encryption, byte[] key, byte[] iv) { }

	// RVA: 0x1B5A040 Offset: 0x1B5A141 VA: 0x1B5A040 Slot: 15
	protected override void ECB(byte[] input, byte[] output) { }

	// RVA: 0x1B59F60 Offset: 0x1B5A061 VA: 0x1B59F60
	private uint SubByte(uint a) { }

	// RVA: 0x1B5A060 Offset: 0x1B5A161 VA: 0x1B5A060
	private void Encrypt128(byte[] indata, byte[] outdata, uint[] ekey) { }

	// RVA: 0x1B5BEB0 Offset: 0x1B5BFB1 VA: 0x1B5BEB0
	private void Decrypt128(byte[] indata, byte[] outdata, uint[] ekey) { }

	// RVA: 0x1B5DCF0 Offset: 0x1B5DDF1 VA: 0x1B5DCF0
	private static void .cctor() { }
}

internal class AesTransform : SymmetricTransform // TypeDefIndex: 2161
{
	// Fields
	private uint[] expandedKey; // 0x58
	private int Nk; // 0x60
	private int Nr; // 0x64
	private static readonly uint[] Rcon; // 0x0
	private static readonly byte[] SBox; // 0x8
	private static readonly byte[] iSBox; // 0x10
	private static readonly uint[] T0; // 0x18
	private static readonly uint[] T1; // 0x20
	private static readonly uint[] T2; // 0x28
	private static readonly uint[] T3; // 0x30
	private static readonly uint[] iT0; // 0x38
	private static readonly uint[] iT1; // 0x40
	private static readonly uint[] iT2; // 0x48
	private static readonly uint[] iT3; // 0x50

	// Methods

	// RVA: 0x1B58C60 Offset: 0x1B58D61 VA: 0x1B58C60
	public void .ctor(Aes algo, bool encryption, byte[] key, byte[] iv) { }

	// RVA: 0x1B5A040 Offset: 0x1B5A141 VA: 0x1B5A040 Slot: 15
	protected override void ECB(byte[] input, byte[] output) { }

	// RVA: 0x1B59F60 Offset: 0x1B5A061 VA: 0x1B59F60
	private uint SubByte(uint a) { }

	// RVA: 0x1B5A060 Offset: 0x1B5A161 VA: 0x1B5A060
	private void Encrypt128(byte[] indata, byte[] outdata, uint[] ekey) { }

	// RVA: 0x1B5BEB0 Offset: 0x1B5BFB1 VA: 0x1B5BEB0
	private void Decrypt128(byte[] indata, byte[] outdata, uint[] ekey) { }

	// RVA: 0x1B5DCF0 Offset: 0x1B5DDF1 VA: 0x1B5DCF0
	private static void .cctor() { }
}

internal class AesTransform : SymmetricTransform // TypeDefIndex: 2161
{
	// Fields
	private uint[] expandedKey; // 0x58
	private int Nk; // 0x60
	private int Nr; // 0x64
	private static readonly uint[] Rcon; // 0x0
	private static readonly byte[] SBox; // 0x8
	private static readonly byte[] iSBox; // 0x10
	private static readonly uint[] T0; // 0x18
	private static readonly uint[] T1; // 0x20
	private static readonly uint[] T2; // 0x28
	private static readonly uint[] T3; // 0x30
	private static readonly uint[] iT0; // 0x38
	private static readonly uint[] iT1; // 0x40
	private static readonly uint[] iT2; // 0x48
	private static readonly uint[] iT3; // 0x50

	// Methods

	// RVA: 0x1B58C60 Offset: 0x1B58D61 VA: 0x1B58C60
	public void .ctor(Aes algo, bool encryption, byte[] key, byte[] iv) { }

	// RVA: 0x1B5A040 Offset: 0x1B5A141 VA: 0x1B5A040 Slot: 15
	protected override void ECB(byte[] input, byte[] output) { }

	// RVA: 0x1B59F60 Offset: 0x1B5A061 VA: 0x1B59F60
	private uint SubByte(uint a) { }

	// RVA: 0x1B5A060 Offset: 0x1B5A161 VA: 0x1B5A060
	private void Encrypt128(byte[] indata, byte[] outdata, uint[] ekey) { }

	// RVA: 0x1B5BEB0 Offset: 0x1B5BFB1 VA: 0x1B5BEB0
	private void Decrypt128(byte[] indata, byte[] outdata, uint[] ekey) { }

	// RVA: 0x1B5DCF0 Offset: 0x1B5DDF1 VA: 0x1B5DCF0
	private static void .cctor() { }
}

internal class AesTransform : SymmetricTransform // TypeDefIndex: 2161
{
	// Fields
	private uint[] expandedKey; // 0x58
	private int Nk; // 0x60
	private int Nr; // 0x64
	private static readonly uint[] Rcon; // 0x0
	private static readonly byte[] SBox; // 0x8
	private static readonly byte[] iSBox; // 0x10
	private static readonly uint[] T0; // 0x18
	private static readonly uint[] T1; // 0x20
	private static readonly uint[] T2; // 0x28
	private static readonly uint[] T3; // 0x30
	private static readonly uint[] iT0; // 0x38
	private static readonly uint[] iT1; // 0x40
	private static readonly uint[] iT2; // 0x48
	private static readonly uint[] iT3; // 0x50

	// Methods

	// RVA: 0x1B58C60 Offset: 0x1B58D61 VA: 0x1B58C60
	public void .ctor(Aes algo, bool encryption, byte[] key, byte[] iv) { }

	// RVA: 0x1B5A040 Offset: 0x1B5A141 VA: 0x1B5A040 Slot: 15
	protected override void ECB(byte[] input, byte[] output) { }

	// RVA: 0x1B59F60 Offset: 0x1B5A061 VA: 0x1B59F60
	private uint SubByte(uint a) { }

	// RVA: 0x1B5A060 Offset: 0x1B5A161 VA: 0x1B5A060
	private void Encrypt128(byte[] indata, byte[] outdata, uint[] ekey) { }

	// RVA: 0x1B5BEB0 Offset: 0x1B5BFB1 VA: 0x1B5BEB0
	private void Decrypt128(byte[] indata, byte[] outdata, uint[] ekey) { }

	// RVA: 0x1B5DCF0 Offset: 0x1B5DDF1 VA: 0x1B5DCF0
	private static void .cctor() { }
}

